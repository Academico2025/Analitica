<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Atlas TI Lite PRO – IA + Análisis Cualitativo (Extended)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- vis-network CDN (JS y CSS) -->
  <script src="https://unpkg.com/vis-network@9.1.9/dist/vis-network.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/vis-network@9.1.9/dist/vis-network.min.css"/>

  <style>
    :root { --pri:#4c51bf; --pri-2:#434190; }
    * { box-sizing: border-box; }
    body { font-family: Segoe UI, Arial, sans-serif; background:#f5f6fa; margin:0; color:#232323; }
    header { background:var(--pri); color:#fff; padding:1.5rem 1rem; text-align:center; }
    .container { max-width:1200px; margin:2rem auto; padding:2rem; background:#fff; border-radius:16px; box-shadow:0 4px 24px #0002; }
    textarea { width:100%; min-height:160px; font-size:1rem; padding:0.7rem; border-radius:8px; border:1px solid #b3b3b3; margin-bottom:1rem; }
    button { background:var(--pri); color:#fff; border:none; border-radius:12px; padding:0.7rem 1.0rem; font-size:1rem; cursor:pointer; }
    button:hover { background:var(--pri-2); }
    .row { display:flex; gap:1.5rem; }
    .panel { flex:1; min-width:270px; }
    .panel-border { border:1px solid #d1d5db; border-radius:11px; padding:0.9rem; background:#f7fafc; }
    .cloud { font-size:1.1rem; line-height:2rem; margin:12px 0; }
    .cloud span { display:inline-block; margin:0 6px; cursor:pointer; padding:2px 4px; border-radius:6px; background:#eef2ff; }
    .chart-bar { display:flex; align-items:center; gap:10px; margin-bottom:8px; }
    .bar { height:18px; background:#c7d2fe; border-radius:10px; min-width:20px; }
    .percent { color:var(--pri); font-weight:bold; }
    .tabla { border-collapse:collapse; width:100%; margin:7px 0; }
    .tabla th, .tabla td { border:1px solid #bbb; padding:7px 10px; text-align:center; }
    .tabla th { background:var(--pri); color:#fff; }
    .codetag { font-size:.96em; background:#c7d2fe; padding:2px 8px; border-radius:9px; margin:3px 3px 6px 0; color:#2c5282; cursor:pointer; display:inline-block;}
    .codetag.selected, .codetag:hover { background:var(--pri); color:#fff; }
    .fragment { background:#fff59f; border-radius:3px; }
    #network { width:100%; height:260px; border:1px solid #aaa; border-radius:10px; background:#faf9f5; margin-bottom:14px; }
    mark { background:#ffff00; color:#000; }
    .note { font-size:.9rem; color:#555; }
    .error { background:#fee2e2; color:#991b1b; border:1px solid #fecaca; padding:.6rem .8rem; border-radius:8px; margin-top:.6rem; }
    .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
    .pill { background:#e5e7eb; border-radius:999px; padding:6px 10px; }
    .pager { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .pager button { padding:6px 10px; border-radius:8px; }
    @media (max-width:980px) { .row { flex-direction:column; } .panel{ min-width:100px;} #network{ height:200px; } }
  </style>
</head>
<body>
  <header>
    <h1>Atlas TI Lite PRO – Cualitativo Interactivo con IA</h1>
    <div>Admite colecciones grandes (líneas o párrafos) • Resumen largo con IA o local</div>
  </header>

  <div class="container">
    <h2>1) Pega aquí las respuestas</h2>
    <textarea id="input" placeholder="Pega MUCHAS respuestas (líneas o párrafos). El sistema paginará y tomará el máximo seleccionado."></textarea>

    <div class="controls">
      <label class="pill">
        <input type="radio" name="splitMode" value="line" checked /> Separar por <b>líneas</b>
      </label>
      <label class="pill">
        <input type="radio" name="splitMode" value="para" /> Separar por <b>párrafos</b> (doble salto de línea)
      </label>
      <label class="pill">
        Máx. respuestas a procesar:
        <input id="maxResp" type="number" min="20" max="300" step="10" value="200" style="width:80px; margin-left:6px;">
      </label>
      <button onclick="analizar()">Interpretar y graficar</button>
      <button onclick="probarGemini()">Probar API</button>
      <span class="note">Tip: 100–200 respuestas da buen equilibrio entre detalle y rendimiento.</span>
    </div>

    <div class="row" style="margin-top:1.2rem;">
      <!-- Panel Izquierdo -->
      <div class="panel panel-border">
        <h3>Respuestas (selecciona texto y asígnale código)</h3>
        <input type="text" id="search" style="width:80%;" placeholder="Buscar..." oninput="buscarEnRespuestas()" />
        <div id="respuestas" class="note">Aún no hay resultados.</div>
        <div class="pager">
          <button onclick="prevPage()">◀ Anterior</button>
          <span id="pageInfo" class="note">Página 0/0</span>
          <button onclick="nextPage()">Siguiente ▶</button>
        </div>
      </div>

      <!-- Panel Central -->
      <div class="panel panel-border">
        <h3>Códigos manuales</h3>
        <div style="display:flex; gap:8px; align-items:center;">
          <input type="text" id="nuevoCodigo" style="width:66%;" placeholder="Crear nuevo código"/>
          <button onclick="crearCodigo()" style="padding: 0.4rem 1.1rem;">Crear</button>
        </div>
        <div id="listaCodigos" style="margin:10px 0;"><i>No hay códigos aún</i></div>
        <div id="panelCodigos"></div>
      </div>

      <!-- Panel Derecho -->
      <div class="panel panel-border">
        <b>Nube de Palabras</b>
        <div id="cloud" class="cloud note">—</div>
        <b>Frecuencia de Palabras</b>
        <div id="barras" class="note">—</div>
        <b>Red de Co-ocurrencia (Palabras)</b>
        <div id="network"></div>
        <div id="networkError"></div>
        <b>Tabla de palabras</b>
        <table class="tabla" id="tablaPalabras"></table>
      </div>
    </div>

    <div class="panel-border" style="margin-top:1.2rem;">
      <h3>Resumen Automático</h3>
      <div class="note">Con API key de Gemini generará un informe largo con continuaciones; sin IA verás un resumen local extendido.</div>
      <div id="resumen"></div>
    </div>
  </div>

<script>
/* ================== CONFIGURACIÓN IA (usa tu cURL) ================== */
const GEMINI_API_KEY = "AIzaSyBa33PhNslR17CDCgZ6SFOjp_CSm815YKY"; // expuesta para pruebas
const GEMINI_MODEL  = "gemini-2.0-flash";                           // modelo del cURL
/* ================================================================ */

const STOPWORDS = ["de","la","y","el","en","los","del","que","se","con","por","las","para","es","una","un","al","lo","sus","o","a","como","más","le","su","ha","ya","pero","sí","no","fue","son","han","sobre","entre","también","cuando","muy","sin","hay","todo","nos","esta","me","mi","yo","él","tiene","si","qué","quien","desde","porque","hace","esto","cada","solo","donde","puede","ser","hasta"];

let textosRaw=[], textosPaginados=[], page=1, pageSize=30;
let codigos=[], codificaciones={}, selectedCodigo=null, palabrasTop=[], palabrasPorDocente=[];

/* ===== Helpers DOM ===== */
function setHTML(id, html){ const el = document.getElementById(id); if(el) el.innerHTML = html; }
function appendError(id, msg){ const el = document.getElementById(id); if(!el) return; el.innerHTML = `<div class="error">${msg}</div>`; }
function getSplitMode(){ return [...document.getElementsByName('splitMode')].find(r=>r.checked)?.value || 'line'; }

/* ================== Núcleo de análisis ================== */
function analizar() {
  try {
    const raw = (document.getElementById('input').value || "").trim();
    if(!raw) { alert("Pega los textos. Puedes incluir cientos de líneas o párrafos."); return; }

    // Separación configurable
    const mode = getSplitMode();
    let chunks;
    if(mode === 'para') {
      chunks = raw.split(/\r?\n{2,}/).map(t=>t.trim()).filter(Boolean);
    } else {
      chunks = raw.split(/\r?\n+/).map(t=>t.trim()).filter(Boolean);
    }

    // Límite configurable (hasta 300 por UI)
    const maxResp = Math.max(20, Math.min(300, parseInt(document.getElementById('maxResp').value || "200", 10)));
    textosRaw = chunks.slice(0, maxResp);

    // Conteo de palabras
    const frecuencias = {};
    const docentesPalabra = {};
    palabrasPorDocente = textosRaw.map(txt=>{
      const palabras = txt.replace(/[.,;:!?¿¡()"]/g,"").toLowerCase().split(/\s+/)
        .filter(w=>w.length>2 && !STOPWORDS.includes(w));
      const set = new Set(palabras);
      set.forEach(w=>{ docentesPalabra[w]=(docentesPalabra[w]||0)+1; });
      palabras.forEach(w=>{ frecuencias[w]=(frecuencias[w]||0)+1; });
      return set;
    });

    // Top palabras para la RED (15 máx para rendimiento)
    palabrasTop = Object.entries(frecuencias).sort((a,b)=>b[1]-a[1]).slice(0,15).map(([w])=>w);

    // Paginación de respuestas
    page = 1;
    textosPaginados = [];
    for(let i=0; i<textosRaw.length; i+=pageSize){
      textosPaginados.push(textosRaw.slice(i, i+pageSize));
    }

    renderRespuestas();
    renderNube(frecuencias);
    renderBarras(docentesPalabra);
    renderTablaPalabras(docentesPalabra, frecuencias);
    renderCodigos();
    renderRedPalabras(docentesPalabra);
    renderResumen(frecuencias, docentesPalabra);
    document.getElementById('search').value='';

  } catch (e) {
    console.error(e);
    alert("Ocurrió un error al analizar. Revisa la consola (F12) para más detalles.");
  }
}

/* ================== Paginación ================== */
function updatePagerInfo(){
  const total = textosPaginados.length || 0;
  setHTML('pageInfo', `Página ${total?page:0}/${total}`);
}
function prevPage(){
  if(page>1){ page--; renderRespuestas(); }
}
function nextPage(){
  if(page<textosPaginados.length){ page++; renderRespuestas(); }
}

/* ================== Respuestas + Codificación ================== */
function renderRespuestas() {
  updatePagerInfo();
  if(textosPaginados.length===0){ setHTML('respuestas', "<i>Sin resultados.</i>"); return; }
  const slice = textosPaginados[page-1] || [];
  let html='';
  const baseIndex = (page-1)*pageSize;

  slice.forEach((txt,i)=>{
    const safe = txt.replace(/</g,"&lt;").replace(/>/g,"&gt;");
    const idxReal = baseIndex + i;
    html += `<div style="margin-bottom:12px;position:relative;">
      <span style="font-weight:600;color:var(--pri);">Docente ${idxReal+1}:</span>
      <div style="cursor:text;" onmouseup="codificarFragmento(${idxReal})" id="texto${idxReal}">
        ${resaltarCodigos(safe, idxReal)}
      </div>
    </div>`;
  });
  setHTML('respuestas', html);
}

function resaltarCodigos(txt,index){
  if(!codificaciones[index]) return txt;
  const frag = codificaciones[index].slice().sort((a,b)=>b.start-a.start);
  frag.forEach(code=>{
    txt = txt.substring(0,code.start) + `<span class="fragment" title="Código: ${code.codigo}">${txt.substring(code.start,code.end)}</span>` + txt.substring(code.end);
  });
  return txt;
}

function codificarFragmento(i){
  const sel = window.getSelection();
  const tNode = document.getElementById("texto"+i);
  if(!sel.anchorNode || !tNode || !tNode.contains(sel.anchorNode)) return;
  const text = sel.toString();
  if(!text.trim()) return;
  const code = prompt(`Asignar código a:\n"${text}"\n(Si no existe, se creará)`);
  if(!code) return;

  const fullText = (tNode.innerText||tNode.textContent);
  const idx = fullText.indexOf(text);
  const start = idx >= 0 ? idx : 0;
  const end   = start + text.length;

  if(!codificaciones[i]) codificaciones[i]=[];
  if(!codigos.includes(code)) codigos.push(code);
  codificaciones[i].push({codigo: code, texto: text, start, end});
  renderRespuestas();
  renderCodigos();
}

/* ================== Panel de Códigos ================== */
function crearCodigo(){
  const code = (document.getElementById('nuevoCodigo').value||"").trim();
  if(!code || codigos.includes(code)) return;
  codigos.push(code);
  document.getElementById('nuevoCodigo').value='';
  renderCodigos();
}

function renderCodigos(){
  let html='';
  codigos.forEach(c=>{
    let count=0;
    textosRaw.forEach((_,i)=>{
      if(codificaciones[i]) codificaciones[i].forEach(f=>{ if(f.codigo===c) count++; });
    });
    html += `<span class="codetag${selectedCodigo===c?' selected':''}" onclick="filtrarPorCodigo('${c}')">${c} (${count})</span>`;
  });
  setHTML('listaCodigos', html || "<i>No hay códigos aún</i>");

  let fragshtml='';
  if(selectedCodigo){
    fragshtml += `<b>Fragmentos para <span style="color:var(--pri)">${selectedCodigo}</span>:</b><ul>`;
    textosRaw.forEach((_,i)=>{
      if(codificaciones[i]){
        codificaciones[i].forEach(f=>{
          if(f.codigo===selectedCodigo)
            fragshtml+=`<li><b>Docente ${i+1}:</b> <span class="fragment">${f.texto}</span></li>`;
        });
      }
    });
    fragshtml+="</ul>";
  }
  setHTML('panelCodigos', fragshtml);
}

function filtrarPorCodigo(c){
  selectedCodigo = (selectedCodigo===c ? null : c);
  renderCodigos();
  renderRespuestas();
}

/* ================== Nube, Barras, Tabla ================== */
function renderNube(frecuencias){
  const top = Object.entries(frecuencias).sort((a,b)=>b[1]-a[1]).slice(0,30);
  const html = top.map(([w])=>`<span onclick="buscarNube('${w}')">${w}</span>`).join(' ');
  setHTML('cloud', html || "—");
}
function renderBarras(docentesPalabra){
  const top = Object.entries(docentesPalabra).sort((a,b)=>b[1]-a[1]).slice(0,15);
  const total = textosRaw.length || 1;
  const html = top.map(([w,c])=>{
    const perc = ((c/total)*100).toFixed(1);
    const wpx = Math.max(20, c*18);
    return `<div class="chart-bar">
      <span style="width:140px;display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${w}</span>
      <div class="bar" style="width:${wpx}px"></div>
      <span class="percent">${perc}% docentes</span>
    </div>`;
  }).join('');
  setHTML('barras', html || "—");
}
function renderTablaPalabras(docentesPalabra, frecuencias){
  let table = `<tr><th>Palabra</th><th>Frecuencia</th><th>% Docentes</th></tr>`;
  const total = textosRaw.length || 1;
  const rows = Object.entries(docentesPalabra).sort((a,b)=>b[1]-a[1]).slice(0,12);
  if(rows.length===0) { setHTML('tablaPalabras', ""); return; }
  rows.forEach(([w,c])=>{
    const perc = ((c/total)*100).toFixed(1);
    table += `<tr><td><b>${w}</b></td><td>${frecuencias[w]||c}</td><td>${perc}%</td></tr>`;
  });
  setHTML('tablaPalabras', table);
}

/* ================== Red de co-ocurrencias (con estabilización y parada) ================== */
function renderRedPalabras(docentesPalabra){
  try {
    const container = document.getElementById('network');
    const warn = document.getElementById('networkError');
    if(warn) warn.innerHTML = '';
    if(!container){ return; }

    if(!window.vis || !vis.Network){
      appendError("networkError", "No se pudo cargar el componente de red (vis-network). Continúas con el resto del análisis.");
      return;
    }

    // Construcción (top ya limitado a 15)
    const top = palabrasTop.slice();
    const pares = {};
    const nodes = [];
    const edges = [];

    palabrasPorDocente.forEach(set=>{
      top.forEach(w1=>{
        if(set.has(w1)){
          top.forEach(w2=>{
            if(w2!==w1 && set.has(w2)){
              const key = [w1,w2].sort().join('—');
              pares[key] = (pares[key]||0)+1;
            }
          });
        }
      });
    });

    top.forEach(w=>{
      nodes.push({
        id: w,
        label: w,
        value: (docentesPalabra[w]||1),
        color: "#4c51bf",
        font: { size: 16, color: '#434190' }
      });
    });

    Object.entries(pares).forEach(([key,val])=>{
      if(val > 1){
        const [a,b] = key.split('—');
        edges.push({
          from: a,
          to: b,
          width: 1 + Math.min(val, 4),
          color: { color:'#90cdf4' },
          smooth: { type: 'dynamic' }
        });
      }
    });

    if(nodes.length < 2 || edges.length === 0){
      container.innerHTML = '';
      appendError("networkError", "No hay suficientes co-ocurrencias para dibujar la red (prueba con más respuestas o menos stopwords).");
      return;
    }

    container.innerHTML = '';
    const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };

    const options = {
      layout: { improvedLayout: true, randomSeed: 42 },
      physics: {
        enabled: true,
        solver: 'forceAtlas2Based',
        forceAtlas2Based: {
          gravitationalConstant: -30,
          springConstant: 0.08,
          springLength: 120,
          damping: 0.45,
          avoidOverlap: 0.2
        },
        stabilization: { enabled: true, iterations: 200, updateInterval: 25, fit: true }
      },
      nodes: { shape: 'dot', size: 22, scaling: { min: 12, max: 32 } },
      edges: { color: { color:'#ddd' }, selectionWidth: 4 },
      interaction: { hover: true, zoomView: true, dragView: true, dragNodes: true }
    };

    const network = new vis.Network(container, data, options);

    // 🔒 Desactivar física al estabilizar para que el grafo quede quieto
    network.once('stabilizationIterationsDone', function () {
      network.setOptions({ physics: false });
    });

  } catch (e){
    console.error(e);
    appendError("networkError", "Ocurrió un problema dibujando la red. Revisa la consola.");
  }
}

/* ================== Resumen (IA largo con continuaciones + fallback) ================== */
async function renderResumen(frecuencias, docentesPalabra){
  const palabrasFrecuentes = Object.entries(frecuencias).sort((a,b)=>b[1]-a[1]);
  let interpretacion = `Se analizaron <b>${textosRaw.length}</b> respuestas.<br>`;
  interpretacion += `Palabras más frecuentes: <b>${palabrasFrecuentes.slice(0,8).map(([w])=>w).join(', ') || "—"}</b>.<br>`;

  const rawText = textosRaw.join(" ");
  const MAX_CHARS = 9500;
  const sample = rawText.length > MAX_CHARS ? rawText.slice(0, MAX_CHARS) : rawText;

  if(!sample){
    document.getElementById('resumen').innerHTML = interpretacion + "<i>Sin texto para resumir.</i>";
    return;
  }

  if(!GEMINI_API_KEY){
    const local = resumenLocalHeuristicoExtendido(frecuencias);
    document.getElementById('resumen').innerHTML = interpretacion + `<br><b>Resumen (local):</b> ${local}`;
    return;
  }

  const top8 = palabrasFrecuentes.slice(0,8).map(([w])=>w).join(', ');
  const promptBase = `
Eres analista cualitativo senior. Escribe un INFORME SÓLIDO y EXTENSO (700–1000 palabras) en español, bien estructurado y sin relleno, sobre respuestas de docentes.

Estructura y requisitos (formatea en estilo Markdown con subtítulos, listas y tablas en texto):
1) **Hallazgos clave** (4–7 puntos).
2) **Evidencias textuales sintéticas**: 6–10 citas reconstruidas breves (no literales).
3) **Matriz de temas vs. % de docentes** (6–8 filas, estimado).
4) **Causas raíz (5 Porqués)** en 2 problemas.
5) **Implicaciones** (3–5).
6) **Plan de acción 90 días** (6–10 acciones SMART con responsable y métrica).
7) **Limitaciones** (2–3).

Palabras frecuentes para orientar: ${top8}.
Texto a analizar (muestra): ${sample}
Estilo claro y profesional, evita repetir.`;

  try {
    const cuerpo = {
      contents: [{ parts: [{ text: promptBase }] }],
      generationConfig: {
        temperature: 0.35,
        maxOutputTokens: 1400,
        topK: 32,
        topP: 0.9
      }
    };

    const ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;
    const headers = { "Content-Type": "application/json", "X-goog-api-key": GEMINI_API_KEY };

    let resumen = await llamarGemini(ENDPOINT, headers, cuerpo);

    // Ampliaciones si quedó corto
    let intentos = 0;
    while ((resumen.replace(/\s+/g,' ').length < 2500) && intentos < 2) {
      const promptContinuacion = `
AMPLÍA SIN REPETIR contenido previo. Profundiza en:
- variaciones por perfil docente,
- tensiones y trade-offs,
- riesgos y mitigaciones,
- indicadores (leading/lagging) con fórmulas,
- rúbrica (4 niveles) para evaluar avance.`;
      const cuerpo2 = {
        contents: [
          { parts: [{ text: promptBase }] },
          { parts: [{ text: resumen }] },
          { parts: [{ text: promptContinuacion }] }
        ],
        generationConfig: {
          temperature: 0.35,
          maxOutputTokens: 1200,
          topK: 32,
          topP: 0.9
        }
      };
      const extra = await llamarGemini(ENDPOINT, headers, cuerpo2);
      resumen += `\n\n---\n\n${extra}`;
      intentos++;
    }

    document.getElementById('resumen').innerHTML = interpretacion + `<br><b>Resumen (IA Gemini):</b><br>` + resumen;

  } catch (err) {
    console.error(err);
    const local = resumenLocalHeuristicoExtendido(frecuencias);
    document.getElementById('resumen').innerHTML =
      interpretacion +
      `<br><b>Resumen (local por fallo de IA):</b> ${local}` +
      `<div class="error" style="margin-top:.6rem;">Error IA: ${err.message}</div>`;
  }
}

/* ===== Llamada a Gemini con manejo de errores unificado ===== */
async function llamarGemini(url, headers, body){
  const resp = await fetch(url, { method: "POST", headers, body: JSON.stringify(body) });
  if(!resp.ok){
    let detail = "";
    try { detail = (await resp.json())?.error?.message || ""; } catch {}
    throw new Error(`${resp.status} ${resp.statusText}${detail ? " – " + detail : ""}`);
  }
  const data = await resp.json();
  const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;
  if(!text) throw new Error("La respuesta de IA no trajo texto.");
  return text;
}

/* ====== Resumen local extendido (sin IA) ====== */
function resumenLocalHeuristicoExtendido(frecuencias){
  const orden = Object.entries(frecuencias).sort((a,b)=>b[1]-a[1]);
  const top = orden.slice(0,12).map(([w])=>w);
  if(top.length===0) return "Las respuestas son muy breves o heterogéneas; no se observan patrones robustos.";

  const temas = top.slice(0,6);
  const soporte = top.slice(6,12);

  return `
**Hallazgos clave.** Aparecen de forma reiterada los temas: ${temas.join(", ")}. Se conectan con términos de soporte como ${soporte.join(", ")}.

**Evidencias textuales sintéticas.** “Faltan tiempos protegidos para planear”, “mejoró la relación con familias, pero no es constante”, “se requiere formación práctica en TIC”.

**Matriz de temas vs. % docentes (estimado).**
- ${temas[0]} — 60–80%
- ${temas[1]} — 50–70%
- ${temas[2]} — 40–60%
- ${temas[3]} — 30–50%
- ${temas[4]} — 25–45%
- ${temas[5]} — 20–40%

**Causas raíz (5 Porqués).** Cuellos de botella: organización del tiempo, dotación, coordinación interna.

**Plan de acción (90 días).** 6–10 acciones SMART: responsables claros, calendarización, checklist de aula, microcapacitaciones, seguimiento quincenal, tablero de indicadores.

**Limitaciones.** Muestra no probabilística y vocabulario libre; requiere validación adicional.`;
}

/* ================== Búsqueda y resaltado ================== */
function buscarNube(palabra){
  document.getElementById('search').value = palabra;
  buscarEnRespuestas();
}
function buscarEnRespuestas() {
  const q = (document.getElementById('search').value||"").trim().toLowerCase();
  if(textosPaginados.length===0){ setHTML('respuestas', "<i>Sin resultados.</i>"); return; }
  const slice = textosPaginados[page-1] || [];
  const baseIndex = (page-1)*pageSize;

  let html='';
  slice.forEach((txt,i)=>{
    let safe = txt.replace(/</g,"&lt;").replace(/>/g,"&gt;");
    const idxReal = baseIndex + i;
    safe = resaltarCodigos(safe, idxReal);
    if(q && safe.toLowerCase().includes(q)){
      const regex = new RegExp(`(${q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, "gi");
      safe = safe.replace(regex, '<mark>$1</mark>');
    }
    html += `<div style="margin-bottom:12px;"><b>Docente ${idxReal+1}:</b><div>${safe}</div></div>`;
  });
  setHTML('respuestas', html || "<i>No hay resultados.</i>");
}

/* ================== Botón de prueba rápida de API ================== */
async function probarGemini(){
  try {
    if(!GEMINI_API_KEY){
      alert("Configura GEMINI_API_KEY primero."); return;
    }
    const ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;
    const resp = await fetch(ENDPOINT, {
      method: "POST",
      headers: { "Content-Type": "application/json", "X-goog-api-key": GEMINI_API_KEY },
      body: JSON.stringify({
        contents: [{ parts: [{ text: "Explain how AI works in a few words" }] }]
      })
    });
    if(!resp.ok){
      let detail=""; try{ detail=(await resp.json())?.error?.message||"";}catch{}
      throw new Error(`${resp.status} ${resp.statusText}${detail? " – "+detail: ""}`);
    }
    const data = await resp.json();
    const text = data?.candidates?.[0]?.content?.parts?.[0]?.text || "(sin texto)";
    console.log("Gemini OK:", text);
    alert("Gemini respondió:\n\n" + text);
  } catch(e){
    console.error(e);
    alert("Error al llamar Gemini: " + e.message);
  }
}
</script>
</body>
</html>
